'use strict';

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

require("babel-polyfill");
const CDP = require("chrome-remote-interface");
const fs = require("fs");
const request = require('request');
const sp = require('child_process');
const os = require('os');
const path = require('path');

let AWS = require('aws-sdk');
// AWS.config.loadFromPath('./awsconfig.json')
let s3 = new AWS.S3();

const hat = require('hat');

const userAgentList = ["Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.94 Safari/537.36", "Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.94 Safari/537.36", "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:57.0) Gecko/20100101 Firefox/57.0", "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.94 Safari/537.36", "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.94 Safari/537.36", "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_1) AppleWebKit/604.3.5 (KHTML, like Gecko) Version/11.0.1 Safari/604.3.5"];

class Chrome {

	constructor(params) {
		this.chrome = null;
		this.debugLevel = 'DEVELOPPEMENT';
		this.viewPort = { width: 1200, height: 800 };
		this.userAgent = this.getRandomUserAgent();
		this.mainParams = null;
		this.proxyConfiguration = null;
		this.debugRequest = false;
		//params.CHROME_PATH||process.env.GOOGLE_CHROME_BIN||process.env.GOOGLE_CHROME_SHIM
		this.CHROME_PATH = path.resolve(__dirname, './headless-chromium');
		console.log('chrome path is', this.CHROME_PATH);
		if (params.CHROME_PATH) this.CHROME_PATH = params.CHROME_PATH;
		this.currentProcess;
		this.browserContextId;
		this.chromePort;
		if (params && params.DEBUG) this.debugLevel = params.DEBUG;
		if (params && params.userAgent) this.userAgent = params.userAgent;else this.userAgent = userAgentList[Math.floor(Math.random() * userAgentList.length)];
		if (params && params.port) {
			this.chromePort = params.port;
		}
		this.CanaryArgs = ['--headless', '--remote-debugging-port=' + (params.port || 9222), '--disable-gpu', '--enable-logging', '--single-process', '--no-zygote', '--no-sandbox'];
		console.log(this.CanaryArgs);
		if (params && params.proxyConfiguration) {
			this.proxyConfiguration = params.proxyConfiguration;
			if (this.proxyConfiguration.host && this.proxyConfiguration.port) {
				this.proxyConfiguration.url = 'http://' + this.proxyConfiguration.host + ':' + this.proxyConfiguration.port;
				this.CanaryArgs.push('--proxy-server=' + this.proxyConfiguration.host + ':' + this.proxyConfiguration.port);
			}
		}
		if (params && params.debugRequest) this.debugRequest = params.debugRequest;
		if (params && params.viewPort && params.viewPort.width && params.viewPort.height) {
			this.viewPort = { width: params.viewPort.width, height: params.viewPort.height };
			this.CanaryArgs.push('--window-size=' + params.viewPort.width + ',' + params.viewPort.height + '');
		} else {
			this.CanaryArgs.push('--window-size=1280,800');
		}
	}

	getAvailablePort(port) {
		return new Promise((resolve, reject) => {
			if (!port) {
				port = 9222;
			}
			request({ url: 'http://127.0.0.1:' + port + '/json' }, (err, body) => {
				if (err) {
					console.log('err port', err);
					resolve(port);
				} else {
					this.getAvailablePort(port + 1).then(result => {
						this.chromePort = port;
						resolve(result);
					}).catch(e => {
						reject(e);
					});
				}
			});
		});
	}
	/*
 	Display message on console when app is in Developpement
 */
	logDev(message) {
		if (this.debugLevel === 'DEVELOPPEMENT') console.log(message);
	}

	logRequest(request) {
		if (this.debugRequest) console.log(request);
	}

	/*
 	Save file to local
 */
	saveLocalFile(fileUrl, data, type) {
		return new Promise((resolve, reject) => {
			fs.writeFile(fileUrl, data, type, (err, result) => {
				if (err) {
					this.logDev(err);
					reject(err);
				}
				resolve(fileUrl);
			});
		});
	}
	/*
    Read file
  */
	readFile(filePath) {
		return new Promise((resolve, reject) => {
			fs.exists(filePath, exists => {
				if (exists) {
					// results true
					fs.readFile(filePath, { encoding: "utf8" }, (err, data) => {
						if (err) {
							logDev(err);
							resolve(null);
						}
						resolve(data);
					});
				} else {
					resolve(null);
				}
			});
		});
	}
	/*
 	Get a valid and recent userAgent list
 */
	getRandomUserAgent() {
		const idx = Math.floor(Math.random() * userAgentList.length - 1);
		return userAgentList[idx] || userAgentList[0];
	}
	/*
 	Configuration of params
 */

	chromeIsRunning() {
		return new Promise((resolve, reject) => {
			request({ url: 'http://127.0.0.1:' + this.chromePort + '/json' }, (err, result, body) => {
				if (err) {
					reject(err);
				} else {
					resolve(body);
				}
			});
		});
	}
	/*
 	Wait chrome launch
 */
	waitForChrome(retry, maxRetry) {
		return new Promise((resolve, reject) => {
			if (retry <= maxRetry) {
				this.chromeIsRunning().then(result => {
					console.log('Result', result);
					resolve({ statut: true });
				}).catch(e => {
					this.logDev('**************\nWaiting for chrome\nAttempt nÂ°' + retry + '\n**************');
					setTimeout(() => {
						this.waitForChrome(retry + 1, maxRetry).then(result => {
							resolve(result);
						}).catch(err => {
							reject(err);
						});
					}, 100);
				});
			} else {
				reject(new Error('Timeout while waiting for Chrome process'));
			}
		});
	}
	/*
 	Launch Chrome process
 */
	launchChromeProcess() {
		var _this = this;

		return _asyncToGenerator(function* () {
			if (_this.CHROME_PATH) {
				let chrome = null;
				try {
					console.log('temp dir', os.tmpdir());
					console.log('SPAWN CHROME', _this.CanaryArgs);
					chrome = sp.spawn(_this.CHROME_PATH, _this.CanaryArgs, {
						cwd: os.tmpdir(),
						detached: true,
						stdio: 'ignore'
					});
					console.log(chrome);
					// .on('close', () => console.log('CHROME_PROCESS_CLOSE'))
					// .on('error', e => console.log('CHROME_PROCESS_ERROR', e))
					// .on('exit', (e, z, a) => console.log('CHROME_PROCESS_EXIT', e, z, a))
					// .on('data', (data) => {console.log('data is',data)})
					if (chrome) {
						chrome.unref();
						console.log('PID value', chrome.pid);
						_this.currentProcess = chrome;
					}
					return { statut: true };
				} catch (e) {
					console.log('Error here', e);
					return { statut: false };
				}
			} else {
				console.log('Throwing new error : Chrome path not defined');
				throw new Error('Chrome path not defined');
			}
		})();
	}

	getWebSocketDebuggerUrl() {
		var _this2 = this;

		return _asyncToGenerator(function* () {
			return new Promise(function (resolve, reject) {
				request({ url: 'http://127.0.0.1:' + _this2.chromePort + '/json/version', 'method': 'GET' }, function (err, response, body) {
					if (err) {
						reject(err);
					} else {
						if (typeof body === "string") {
							try {
								body = JSON.parse(body);
							} catch (e) {
								body = body;
							}
						}
						if (body && body.webSocketDebuggerUrl) {
							resolve(body.webSocketDebuggerUrl);
						} else if (body && body.length > 0) {
							resolve(body[0].webSocketDebuggerUrl);
						} else {
							resolve(null);
						}
					}
				});
			});
		})();
	}

	createTarget(host, port, secure) {
		return _asyncToGenerator(function* () {
			return new Promise(function (resolve, reject) {
				CDP.New({ host, port, secure }, function (err, target) {
					if (err) {
						console.log('Error here', err);
						resolve(null);
					} else {
						resolve(target);
					}
				});
			});
		})();
	}
	/*
 	Launch instance of Chrome headless navigator
 */
	launch(params) {
		var _this3 = this;

		return _asyncToGenerator(function* () {
			try {
				/*
    	Lancement de canary
    */
				let isAlreadyRunning;
				_this3.logDev('New attempt to launch Chrome');
				let portAvailable;
				console.log("chromePort", _this3.chromePort);
				if (!_this3.chromePort) portAvailable = yield _this3.getAvailablePort();else portAvailable = _this3.chromePort;
				console.log('available port', portAvailable);
				if (!portAvailable) {
					throw new Error('No port available');
				}
				_this3.CanaryArgs[1] = '--remote-debugging-port=' + portAvailable;
				_this3.chromePort = portAvailable;
				let isLaunch = yield _this3.launchChromeProcess();
				if (!isLaunch || isLaunch && !isLaunch.statut) {
					return { statut: false, message: 'An error occured while launching Chrome' };
				}
				yield _this3.waitForChrome(0, 250);
				let debugUrl;
				try {
					debugUrl = yield _this3.getWebSocketDebuggerUrl();
					console.log(debugUrl);
				} catch (e) {
					return { statut: false, message: `${e.message}` };
				}
				console.log('port', _this3.chromePort);
				// target:debugUrl
				const target = yield _this3.createTarget('localhost', _this3.chromePort, false);
				console.log(target);
				_this3.chrome = yield CDP({ remote: true, host: 'localhost', port: _this3.chromePort, target });
				_this3.logDev('0) New context created. Session is now isolated.');
				_this3.logDev('1) Chrome launched');
				try {
					console.log('Then');
					yield _this3.chrome.Page.enable();
				} catch (e) {
					console.log('Error ', e);
				}
				console.log('Enable chrome log', (yield _this3.chrome.Log.enable()));

				yield _this3.chrome.Console.clearMessages();
				_this3.chrome.Console.messageAdded(function (params) {
					console.log(params);
				});
				_this3.chrome.Log.entryAdded(function (logEntry) {
					console.log(logEntry);
				});

				_this3.logDev('2) Page domain notification enabled');
				yield _this3.chrome.Network.enable();
				_this3.logDev('3) Network enabled');
				yield _this3.chrome.Network.setUserAgentOverride({ userAgent: _this3.userAgent });
				_this3.logDev('4) UserAgent set' + _this3.userAgent);

				if (_this3.chrome.Network.setRequestInterception && typeof _this3.chrome.Network.setRequestInterception === "function") {
					yield _this3.chrome.Network.setRequestInterception({ patterns: [{ urlPattern: 'https://*' }] });
				} else {
					yield _this3.chrome.Network.setRequestInterceptionEnabled({ enabled: true });
				}

				_this3.logDev('5) Request intercepted enabled');
				_this3.chrome.Network.requestIntercepted(_this3.interceptRequest.bind(_this3));
				_this3.logDev('6) Watching request now');
				_this3.chrome.Network.clearBrowserCookies();
				_this3.logDev('7) Cookies deleted');
				// const jQueryData = await this.readFile('./resources/jquery.min.js')
				// await this.chrome.Page.addScriptToEvaluateOnLoad({ scriptSource: 'console.log(Lol);alert("ok")'});
				// await this.chrome.Page.addScriptToEvaluateOnLoad({ scriptSource: jQueryData});
				// await this.delay(2000)

				// console.log(jQueryData)
				// await this.chrome.Page.addScriptToEvaluateOnLoad({ scriptSource: jQueryData });
				// await this.chrome.Page.addScriptToEvaluateOnLoad({ scriptSource: "const jQuery = jQuery.noConflict();" });
				// await this.chrome.Page.addScriptToEvaluateOnLoad({ scriptSource: "console.log(jQuery);" });

				// const jQueryData = await this.readFile('./resources/jquery.min.js')
				// console.log(jQueryData)
				// let temp = await this.chrome.Page.addScriptToEvaluateOnNewDocument({source:jQueryData})
				// console.log(temp)
				// await this.chrome.Page.addScriptToEvaluateOnNewDocument({source:'window.test = true;'})
				// await this.chrome.Page.addScriptToEvaluateOnNewDocument({source:'window.$j = jQuery.noConflict()'})
				// this.logDev('8) Add jQuery for enrich library')
				return { statut: true };
			} catch (err) {
				// console.log('Error whil')
				_this3.logDev(err);
				try {
					yield _this3.killProcess(_this3.currentProcess.pid);
				} catch (e) {
					console.log(e);
				}
				return { statut: false, message: `${err.message}` };
			}
		})();
	}
	/*
 	Open an url and set scroll position to 0,0 (top of page)
 */
	open(url) {
		var _this4 = this;

		return _asyncToGenerator(function* () {
			try {
				yield _this4.chrome.Page.navigate({ url: url });
				_this4.logDev('Page open');
				yield _this4.chrome.Page.loadEventFired();
				_this4.logDev('Page loaded');
				const js = "window.scrollTo(0,0)";
				const result = yield _this4.chrome.Runtime.evaluate({ expression: js, userGesture: true });
				let syn = yield _this4.readFile(path.resolve(__dirname, './lib/syn.js'));
				yield _this4.chrome.Runtime.evaluate({ expression: syn, userGesture: true });
				let jQuery = yield _this4.readFile(path.resolve(__dirname, './lib/jquery.min.js'));
				yield _this4.chrome.Runtime.evaluate({ expression: jQuery, userGesture: true });
				_this4.logDev('Scroll to 0,0');
				return { statut: true };
			} catch (err) {
				_this4.logDev(err);
				return { statut: false, message: `${err.message}` };
			}
		})();
	}
	/*
 	Set Aws credentials - todo
 */
	setAwsCredentials() {}

	evaluate(script) {
		var _this5 = this;

		return _asyncToGenerator(function* () {
			try {
				const result = yield _this5.chrome.Runtime.evaluate({ expression: script, userGesture: true });
				console.log('result evaluation', result);
				return { statut: true, result };
			} catch (e) {
				console.log(e);
				return { statut: false, error: e };
			}
		})();
	}
	/*
 	Save current page to pdf - todo
 */
	saveToPdf(fileUrl) {
		return _asyncToGenerator(function* () {})();
	}
	/*
 	Send request
 */
	send(params) {
		var _this6 = this;

		return _asyncToGenerator(function* () {
			let configRequest = {
				method: 'GET'
			};
			let method = 'GET';
			let rep;
			if (params.method) configRequest.method = params.method;
			if (params.qs) configRequest.qs = params.qs;
			if (params.proxy) configRequest.proxy = params.proxy;
			if (params.headers) configRequest.headers = params.headers;
			if (!params.url) return { statut: false, message: 'Missing url in params' };
			if (params.url) configRequest.url = params.url;
			if (params.form) {
				configRequest.form = params.form;
			}
			if (params.json) {
				configRequest.json = params.json;
			}
			try {
				rep = yield request(configRequest);
			} catch (e) {
				_this6.logDev(e);
				throw e;
			}
			console.log(rep);
			return { statut: true };
		})();
	}
	/*
 	Take a screenshot of the page
 */
	screenshot(fileUrl, format = null, params = null) {
		var _this7 = this;

		return _asyncToGenerator(function* () {
			let base64Data;
			let writeResult;
			const formatAllowed = ['jpeg', 'jpg', 'png'];
			try {
				if (!format) format = 'jpeg';
				//clip:{x:0,y:0,width:this.viewPort.width,height:this.viewPort.height,scale:0.5}
				let paramsForCapture = { format: 'jpeg', fromSurface: true };
				if (params && params.format && formatAllowed.indexOf(params.format) != -1) {
					paramsForCapture.format = params.format;
				}
				if (params && params.clip && typeof params.clip.x === 'number' && typeof params.clip.y === 'number' && params.clip.width === 'number' && params.clip.height === 'number' && params.clip.scale === 'number') {
					paramsForCapture.clip = clip;
				}
				base64Data = yield _this7.chrome.Page.captureScreenshot(paramsForCapture);
				_this7.logDev('Page captured');
			} catch (err) {
				return { statut: false, message: `${err.message}` };
			}
			try {
				writeResult = yield _this7.saveLocalFile(fileUrl, base64Data.data, 'base64');
			} catch (err) {
				_this7.logDev(err);
				return { statut: false, message: `${err.message}` };
			}
			_this7.logDev('File saved : ' + fileUrl);
			return { statut: true, fileUrl: fileUrl };
		})();
	}

	screenshotBase64() {
		var _this8 = this;

		return _asyncToGenerator(function* () {
			let base64Data;
			let format = 'png';
			try {
				let paramsForCapture = { format: 'png', fromSurface: true };
				base64Data = yield _this8.chrome.Page.captureScreenshot(paramsForCapture);
				return { statut: true, data: 'data:image/png;base64,' + base64Data.data };
			} catch (err) {
				return { statut: false, message: `${err.message}` };
			}
		})();
	}

	getPdf() {
		return _asyncToGenerator(function* () {})();
	}

	getCookies(url) {
		var _this9 = this;

		return _asyncToGenerator(function* () {
			let cookies;
			if (url) {
				cookies = yield _this9.chrome.Network.getCookies(url);
			} else {
				cookies = yield _this9.chrome.Network.getAllCookies();
			}
			return cookies;
		})();
	}

	setCookies(cookies) {
		var _this10 = this;

		return _asyncToGenerator(function* () {
			if (!cookies) {
				return { statut: false, message: `cookies missing` };
			}
			let result = false;
			// url, name, value, domain, path, secure, httpOnly, sameSite (Strict,lax), expirationDate
			// console.log(this.chrome.Network)
			if (cookies.length) {
				try {
					for (let cookie in cookies) {
						result = yield _this10.chrome.Network.setCookie(cookie);
					}
					return { statut: true };
				} catch (err) {
					_this10.logDev(err);
					return { statut: false, message: `${err.message}` };
				}
			} else {
				try {
					result = yield _this10.chrome.Network.setCookie(cookies);
					return { statut: true };
				} catch (err) {
					_this10.logDev(err);
					return { statut: false, message: `${err.message}` };
				}
			}
		})();
	}

	exists(selector) {
		var _this11 = this;

		return _asyncToGenerator(function* () {
			let js;
			if (selector && selector.indexOf('/') != -1) {
				js = "document.evaluate('" + selector + "', document, null, XPathResult.FIRST_ORDERED_NODE_TYPE, null).singleNodeValue";
			} else if (selector) {
				js = "document.querySelector('" + selector + "')";
			} else {
				return { statut: false, message: `Missing selector` };
			}
			const result = yield _this11.chrome.Runtime.evaluate({ expression: js });
			if (result && result.result && result.result.objectId) {
				return { statut: true };
			} else {
				return { statut: false, message: `selector ${selector} not found` };
			}
		})();
	}

	extract(data) {
		// {
		// 	name:'name',
		// 	selector:'selector',
		// 	regex:'apply regex',
		// 	multi:true
		// 	children:[
		// 		{
		// 			name:'name',
		// 			selector:'',
		// 			regex:'apply regex',
		// 			multi:false
		// 		},
		// 		{
		// 			name:'name5',
		// 			selector:'selector_children_2',
		// 			multi:true
		// 			children:[
		// 				{
		// 					name:'experience_title'
		// 				}
		// 			]
		// 		}
		// 	]
		// }

		return _asyncToGenerator(function* () {})();
	}

	fetchText(selector) {
		var _this12 = this;

		return _asyncToGenerator(function* () {
			let js;
			js = yield _this12.exists(selector);
			if (!js.statut) {
				return { statut: false };
			}
			if (selector && selector.indexOf('/') != -1) {
				js = "document.evaluate('" + selector + "', document, null, XPathResult.FIRST_ORDERED_NODE_TYPE, null).singleNodeValue.innerHTML";
			} else if (selector) {
				js = "document.querySelector('" + selector + "').innerHTML";
			} else {
				return { statut: false, message: `Missing selector` };
			}
			const result = yield _this12.chrome.Runtime.evaluate({ expression: js });
			console.log(result);
			if (result && result.result && result.result.value) {
				return { statut: true, value: result.result.value };
			} else {
				return { statut: false, message: `No value found for ${selector}` };
			}
		})();
	}

	focus(selector) {
		var _this13 = this;

		return _asyncToGenerator(function* () {
			const params = yield _this13.chrome.DOM.getDocument();
			const options = {
				nodeId: params.root.nodeId,
				selector: selector
			};
			let attributes = [];
			let nodeIds;
			try {
				nodeIds = yield _this13.chrome.DOM.querySelectorAll(options);
			} catch (err) {
				_this13.logDev(err);
				throw err;
			}
			nodeIds = nodeIds.nodeIds[0];
			const res = yield _this13.chrome.DOM.focus({ nodeId: nodeIds });
			console.log(res);
			return { statut: true };
		})();
	}

	removeAttribute(selector, attribute) {
		var _this14 = this;

		return _asyncToGenerator(function* () {

			// const params = await this.chrome.DOM.getDocument()
			// const options = {
			//     nodeId: params.root.nodeId,
			//     selector: selector
			// }
			// let attributes = []
			// let nodeIds
			// try{
			// 	nodeIds = await this.chrome.DOM.querySelectorAll(options)
			// }catch(err){
			// 	this.logDev(err)
			// 	throw err
			// }
			// const result = await this.chrome.DOM.removeAttribute({nodeId:nodeIds.nodeIds[0],name:attribute})
			const exist = yield _this14.exists(selector);
			if (exist) {
				let js;
				if (selector && selector.indexOf('/') != -1 && attribute) {
					// Xpath detected
					js = "document.evaluate(" + selector + ", document, null, XPathResult.FIRST_ORDERED_NODE_TYPE, null).removeAttribute('" + attribute + "')";
				} else if (selector && attribute) {
					// Css detected 
					js = "document.querySelector('" + selector + "').removeAttribute('" + attribute + "')";
					console.log(js);
				} else {
					return { statut: false, message: `Missing selector or value` };
				}
				const result = yield _this14.chrome.Runtime.evaluate({ expression: js, userGesture: true });
				console.log(result);
				if (result.result && result.result.value) {
					return { statut: true };
				} else {
					return { statut: false, message: `Selector ${selector} exists but an error occured` };
				}
			} else {
				return { statut: false, message: `selector ${selector} not found` };
			}
			return { statut: 1 };
		})();
	}

	test(selector) {
		var _this15 = this;

		return _asyncToGenerator(function* () {
			const js = "document.evaluate('" + selector + "', document, null, XPathResult.FIRST_ORDERED_NODE_TYPE, null).singleNodeValue";
			const result = yield _this15.chrome.Runtime.evaluate({ expression: js });
			console.log('result', result);

			if (result && result.result && result.result.objectId) {
				// on recupere les attributs
				// if(typeof result.result.objectId==='string'){
				// 	try{
				// 		result.result.objectId = JSON.parse(result.result.objectId)
				// 	}catch(err){
				// 		throw err
				// 	}
				// }
				console.log('id found', result.result.objectId.id);
				const optionsNode = {
					objectId: result.result.objectId
				};
				const res = yield _this15.chrome.DOM.requestNode(optionsNode);
				console.log('Attribute are', res);
				return true;
			} else {
				console.log('ObjectId', result.result.objectId);
				console.log(typeof result.result.objectId);

				return true;
			}
		})();
	}

	getAttributesBis(selector, attribute) {
		var _this16 = this;

		return _asyncToGenerator(function* () {
			let js;
			js = yield _this16.exists(selector);
			if (!js.statut) {
				return { statut: false };
			}

			if (selector && selector.indexOf('/') != -1) {
				js = "var tabElement = $x('" + selector + "');" + "var valueElement = [];" + "var cpt = 0;" + "for(var item of tabElement){" + "var res = {};" + "res.text = item.innerHTML;" + "res.value = item.value;" + "res.index = cpt;" + "cpt ++;" + "const attributes = item.attributes;" + "for(var key in attributes){" + "res[attributes[key].nodeName] = item.attributes[key].value;" + "}" + "valueElement.push(res);" + "}" + "window.completeAction = JSON.stringify(valueElement);";
			} else if (selector) {
				js = "var tabElement = document.querySelectorAll('" + selector + "');" + "var valueElement = [];" + "var cpt = 0;" + "for(var item of tabElement){" + "var res = {};" + "res.text = item.innerHTML;" + "res.value = item.value;" + "res.index = cpt;" + "cpt ++;" + "const attributes = item.attributes;" + "for(var key in attributes){" + "res[attributes[key].nodeName] = item.attributes[key].value;" + "}" + "valueElement.push(res);" + "}" + "window.completeAction = JSON.stringify(valueElement);";
			} else {
				return { statut: false, message: `Missing selector` };
			}
			let result = yield _this16.chrome.Runtime.evaluate({ expression: js });
			console.log('result are', result);
			result = yield _this16.waitForExpression('window.completeAction', 5000);
			console.log('here result', result);
			if (result.statut) {
				try {
					result = JSON.parse(result.value);
				} catch (e) {
					result = result.value;
				}
			}
			return { statut: 1, value: result
				// if(result && result.result && result.result.value){
				//     return {statut:true}
				// }else{
				//     return {statut:false,message:`No value found for ${selector}`}
				// }
			};
		})();
	}

	getAttributes(selector) {
		var _this17 = this;

		return _asyncToGenerator(function* () {
			const params = yield _this17.chrome.DOM.getDocument();
			const options = {
				nodeId: params.root.nodeId,
				selector: selector
			};
			let attributes = [];
			let nodeIds;
			try {
				nodeIds = yield _this17.chrome.DOM.querySelectorAll(options);
			} catch (err) {
				_this17.logDev(err);
				throw err;
			}
			if (nodeIds) {
				for (let nodeId of nodeIds.nodeIds) {
					const optionsNode = {
						nodeId: nodeId
					};
					let value;
					try {
						value = yield _this17.chrome.DOM.getAttributes(optionsNode);
						const left = yield _this17.chrome.DOM.getOuterHTML(optionsNode);
						value.html = left;
					} catch (err) {
						throw err;
					}
					if (value && value.attributes) {
						let attributesDetail = {};
						for (let i in value.attributes) {
							if (i % 2 == 0) {
								attributesDetail[value.attributes[parseInt(i)]] = value.attributes[parseInt(i) + 1];
							}
						}
						attributes.push(attributesDetail);
					}
				}
			}
			return { statut: true, attributes };
		})();
	}

	getAttribute(selector, attribute) {
		var _this18 = this;

		return _asyncToGenerator(function* () {
			const exist = yield _this18.exists(selector);
			if (exist) {
				let js;
				if (selector && selector.indexOf('/') != -1 && attribute) {
					// Xpath detected
					js = "document.evaluate('" + selector + "', document, null, XPathResult.FIRST_ORDERED_NODE_TYPE, null).getAttribute('" + attribute + "')";
				} else if (selector && attribute) {
					// Css detected 
					js = "document.querySelector('" + selector + "').getAttribute('" + attribute + "')";
					console.log(js);
				} else {
					return { statut: false, message: `Missing selector or value` };
				}
				const result = yield _this18.chrome.Runtime.evaluate({ expression: js, userGesture: true });
				console.log('get attribute', result);
				if (result.result && result.result.value) {
					return { statut: true };
				} else {
					return { statut: false, message: `Selector ${selector} exists but an error occured` };
				}
			} else {
				return { statut: false, message: `selector ${selector} not found` };
			}
			return { statut: 1 };
		})();
	}

	fill(selector, value) {
		var _this19 = this;

		return _asyncToGenerator(function* () {
			let js;
			const exist = yield _this19.exists(selector);
			const id = 'element_' + new Date().getTime();
			let result;
			if (!value) {
				throw new Error('Value missing');
			}
			if (exist) {
				if (selector && selector.indexOf('/') != -1 && value) {
					// Xpath detected
					// js = "document.evaluate('"+selector+"', document, null, XPathResult.FIRST_ORDERED_NODE_TYPE, null).singleNodeValue.value='"+value+"'"
					js = "syn.type(document.evaluate('" + selector + "', document, null, XPathResult.FIRST_ORDERED_NODE_TYPE, null).singleNodeValue, \"" + value + "\",function(){window['" + id + "']=true;resolve(true);})";
				} else if (selector && value) {
					// Css detected 
					// js = "document.querySelector('"+selector+"').value='"+value+"'"
					js = `syn.type(document.querySelector('${selector}'), \`${value}\`,function(){resolve(true);})`;
					// console.log(js)
				} else {
					return { statut: false, message: `Missing selector or value` };
				}
				const expression = `
        new Promise((resolve,reject)=>{
          ${js}
        })
      `;
				result = yield _this19.chrome.Runtime.evaluate({
					expression: expression,
					userGesture: true,
					awaitPromise: true
				});

				if (result.result) {
					console.log(result);
					if (result.statut) {
						try {
							result = JSON.parse(result.value);
						} catch (e) {
							result = result.value;
						}
						console.log(result);
						return { statut: true };
					} else {
						return { statut: false };
					}
				} else {
					return { statut: false, message: `Selector ${selector} exists but an error occured` };
				}
			} else {
				return { statut: false, message: `selector ${selector} not found` };
			}
		})();
	}

	getPosition(selector) {
		var _this20 = this;

		return _asyncToGenerator(function* () {
			let js;
			const exist = yield _this20.exists(selector);
			if (exist) {
				if (selector && selector.indexOf('/') != -1) {
					// Xpath detected
					js = "var currentRect = document.evaluate('" + selector + "', document, null, XPathResult.FIRST_ORDERED_NODE_TYPE, null).singleNodeValue.getBoundingClientRect());";
				} else if (selector) {
					// Css detected 
					js = "var currentRect = document.querySelector('" + selector + "').getBoundingClientRect();";
				} else {
					return { statut: false, message: `Missing selector or value` };
				}
				js += "window.currentRectValue = JSON.stringify({top:currentRect.top,left:currentRect.left,bottom:currentRect.bottom,width:currentRect.width,height:currentRect.height});";
				let result = yield _this20.chrome.Runtime.evaluate({ expression: js, userGesture: true });
				result = yield _this20.waitForExpression('window.currentRectValue', 5000);
				if (result.statut) {
					try {
						result = JSON.parse(result.value);
					} catch (e) {
						result = result.value;
					}
				}
				return { statut: true, result
					// if(result.result && result.result.value){
					//   return {statut:true,result}
					// }else{
					//   return {statut:false,message:`Selector ${selector} exists but an error occured`}
					// }
				};
			} else {
				return { statut: false, message: `selector ${selector} not found` };
			}
		})();
	}

	click(selector) {
		var _this21 = this;

		return _asyncToGenerator(function* () {
			let js;
			const exist = yield _this21.exists(selector);
			if (exist) {
				if (selector && selector.indexOf('/') != -1) {
					// Xpath detected
					// js = "document.evaluate('"+selector+"', document, null, XPathResult.FIRST_ORDERED_NODE_TYPE, null).singleNodeValue.click()"
					js = "syn.click(document.evaluate('" + selector + "', document, null, XPathResult.FIRST_ORDERED_NODE_TYPE, null).singleNodeValue))";
				} else if (selector) {
					// Css detected 
					js = "syn.click(document.querySelector('" + selector + "'))";
					// js = "document.querySelector('"+selector+"').click()"
				} else {
					return { statut: false, message: `Missing selector` };
				}
				const result = yield _this21.chrome.Runtime.evaluate({ expression: js, userGesture: true });
				if (result.result && result.result.type) {
					return { statut: true };
				} else {
					return { statut: false, message: `selector ${selector} exists but an error occured` };
				}
			} else {
				return { statut: false, message: `selector ${selector} not found` };
			}
		})();
	}

	delay(delay) {
		return new Promise((resolve, reject) => {
			if (typeof delay === 'object') {
				if (typeof delay.min === 'number' && delay.max === 'number') {
					// Get a number beetween min and max
					const delayValue = Math.floor(Math.random() * (delay.max - delay.min + 1) + delay.min);
					this.logDev(`Alea time generated : ${delayValue}`);
					setTimeout(() => {
						this.logDev(`Wait : ${delayValue} ms`);
						resolve({ statut: true });
					}, delayValue);
				} else {
					setTimeout(() => {
						this.logDev(`Wait : ${delayValue} ms`);
						resolve({ statut: true });
					}, 1000);
				}
			} else if (typeof delay === 'number') {
				setTimeout(() => {
					this.logDev(`Wait : ${delay} ms`);
					resolve({ statut: true });
				}, delay);
			} else {
				setTimeout(() => {
					this.logDev(`Wait : ${delay} ms`);
					resolve({ statut: true });
				}, 1000);
			}
		});
	}

	currentUrl() {
		var _this22 = this;

		return _asyncToGenerator(function* () {
			let js = "window.location.href";
			const result = yield _this22.chrome.Runtime.evaluate({ expression: js, userGesture: true });
			if (result.result && result.result.value) {
				return { statut: false, value: result.result.value };
			} else {
				return { statut: false, mesage: 'An error occured while getting current url' };
			}
		})();
	}

	scrollTo(params) {
		var _this23 = this;

		return _asyncToGenerator(function* () {
			// Set scrollView
			if (params && typeof params.x === "number" && typeof params.y === "number") {
				const js = "window.scrollTo(0,0)";
				const result = yield _this23.chrome.Runtime.evaluate({ expression: js, userGesture: true });
				_this23.logDev(`Scroll to ${JSON.stringify(params, null, "")}`);
				return { statut: true };
			} else {
				return { statut: false, message: 'Missing params.' };
			}
		})();
	}

	scrollToBottom(speed = 'slow') {
		var _this24 = this;

		return _asyncToGenerator(function* () {
			// we get the final height of document
			let js;
			let jsTab = [];
			let result;
			_this24.logDev(`Scroll begin with speed ${speed}`);
			const SCROLL_PARAMS = { slow: { interval: 250, delay: 30 }, fast: { interval: 500, delay: 10 }
				/*
    	Getting scroll window height
    */
			};js = "document.body.scrollHeight";
			result = yield _this24.chrome.Runtime.evaluate({ expression: js, userGesture: true });
			if (!result || !result.result || result.result.type != 'number') {
				return { statut: false, message: 'No result found' };
			}
			let scrollHeight = result.result.value;
			/*
   	Getting scroll position
   */
			js = "window.scrollY";
			result = yield _this24.chrome.Runtime.evaluate({ expression: js, userGesture: true });
			if (!result || !result.result || result.result.type != 'number') {
				return { statut: false, message: 'No result found' };
			}
			let scrollPosition = result.result.value;
			scrollHeight = scrollHeight - scrollPosition;
			/*
   	Setting maxInterval for scrolling with effect
   */
			const maxInterval = Math.floor(scrollHeight / SCROLL_PARAMS[speed].interval);
			for (let i = 0; i < maxInterval; i++) {
				let interval = SCROLL_PARAMS[speed].interval + Math.ceil(SCROLL_PARAMS[speed].interval * Math.random());
				let delayValue = SCROLL_PARAMS[speed].delay + Math.ceil(SCROLL_PARAMS[speed].delay * Math.random());
				if (scrollHeight - interval > 0) {
					scrollHeight = scrollHeight - interval;
					scrollPosition += interval;
					jsTab.push({ js: "setTimeout(function(){window.scrollTo(0," + scrollPosition + ");}," + delayValue + ");", delay: delayValue });
				} else {
					interval = scrollHeight;
					scrollHeight = 0;
					scrollPosition += interval;
					jsTab.push({ js: "setTimeout(function(){window.scrollTo(0," + scrollPosition + ");}," + delayValue + ");", delay: delayValue });
					break;
				}
			}
			for (let item of jsTab) {
				yield _this24.chrome.Runtime.evaluate({ expression: item.js, userGesture: true });
				yield _this24.delay(item.delay);
			}
			_this24.logDev(`Scroll end with`);
			return { statut: true };
		})();
	}

	waitForElement(element, timeout) {
		var _this25 = this;

		return _asyncToGenerator(function* () {
			let found = (yield _this25.exists(element)).statut;
			// console.log('Found ',found)
			let shouldContinue = true;
			if (!timeout) timeout = 3000;

			const timer = setTimeout(function () {
				shouldContinue = false;
			}, timeout);

			while (!found && shouldContinue) {
				found = (yield _this25.exists(element)).statut;
				console.log(found);
			}
			if (found) {
				clearTimeout(timer);
				return { statut: true };
			} else {
				return { statut: false, message: `Timeout while waiting for ${element} after ${timeout} ms` };
			}
		})();
	}

	waitForOneElement(element, timeout) {
		var _this26 = this;

		return _asyncToGenerator(function* () {

			let found = false;
			for (var i = 0; i < element.length; i++) {
				if ((yield _this26.exists(element)).statut) {
					found = true;
					break;
				}
			}

			let shouldContinue = true;
			if (!timeout) timeout = 3000;

			const timer = setTimeout(function () {
				shouldContinue = false;
			}, timeout);

			while (!found && shouldContinue) {
				for (var i = 0; i < element.length; i++) {
					if ((yield _this26.exists(element)).statut) {
						found = true;
						break;
					}
				}
			}
			if (found) {
				clearTimeout(timer);
				return { statut: true };
			} else {
				return { statut: false, message: `Timeout while waiting after ${timeout} ms` };
			}
		})();
	}

	waitForExpression(expression, timeout) {
		var _this27 = this;

		return _asyncToGenerator(function* () {
			let found = yield _this27.chrome.Runtime.evaluate({ expression, userGesture: true });
			if (found && found.result) found = found.result.value;
			if (!found) {
				let shouldContinue = true;
				const INTERVAL = 100;
				let cpt = 0;
				if (!timeout || typeof timeout != 'number') timeout = 1000;
				let maxCpt = Math.floor(timeout / INTERVAL);
				for (let i = 0; i < maxCpt; i++) {
					found = yield _this27.chrome.Runtime.evaluate({ expression, userGesture: true });
					if (found.result) found = found.result.value;
					cpt++;
					if (found) {
						break;
					} else if (cpt > maxCpt) {
						break;
					}
					yield _this27.delay(INTERVAL);
				}
				if (found) {
					return { statut: true, value: found };
				} else {
					return { statut: false, message: `Timeout while waiting for expression ${expression} after ${timeout} ms` };
				}
			} else {
				return { statut: true, value: found };
			}
		})();
	}

	waitForNewPage(timeout) {
		var _this28 = this;

		return _asyncToGenerator(function* () {
			let shouldContinue = true;
			if (!timeout) timeout = 3000;
			const timer = setTimeout(function () {
				shouldContinue = false;
			}, timeout);
			let currentUrl = (yield _this28.currentUrl()).value;
			let newUrl = currentUrl;
			while (currentUrl === newUrl && shouldContinue) {
				newUrl = (yield _this28.currentUrl()).value;
				// console.log(newUrl)
			}
			if (newUrl != currentUrl) {
				clearTimeout(timer);
				return { statut: true };
			} else {
				return { statut: false, message: `Timeout while waiting for a new page after ${timeout} ms` };
			}
		})();
	}

	injectJquery() {
		var _this29 = this;

		return _asyncToGenerator(function* () {
			let result;
			const jQueryData = yield _this29.readFile('./resources/jquery.min.js');
			console.log('jQuery inject', (yield _this29.chrome.Runtime.evaluate({ expression: jQueryData })));
			yield _this29.delay(1500);
			console.log('jQuery inject step 2', (yield _this29.chrome.Runtime.evaluate({ expression: 'const jQuery = jQuery.noConflict();' })));
			result = yield _this29.chrome.Runtime.evaluate({ expression: 'jQuery' });
			console.log('jQuery value', result);
			return true;
		})();
	}
	// 
	interceptRequest(params) {
		var _this30 = this;

		return _asyncToGenerator(function* () {
			_this30.logRequest(params);
			let continueParams = { interceptionId: params.interceptionId };
			try {
				if (params.authChallenge && params.authChallenge.source === 'Proxy') {
					if (_this30.proxyConfiguration && params.authChallenge.origin === _this30.proxyConfiguration.url) {
						continueParams.authChallengeResponse = {
							response: 'ProvideCredentials',
							username: _this30.proxyConfiguration.username,
							password: _this30.proxyConfiguration.password
						};
					} else {
						// Stop navigation
						continueParams.authChallengeResponse = {
							response: 'CancelAuth'
						};
					}
					_this30.logRequest('************************\nResponse to ' + continueParams.interceptionId + '\n' + JSON.stringify(continueParams, null, "") + '\n************************');
					_this30.chrome.Network.continueInterceptedRequest(continueParams);
				} else {
					_this30.logRequest('************************\nResponse to ' + continueParams.interceptionId + '\n' + JSON.stringify(continueParams, null, "") + '\n************************');
					try {
						_this30.chrome.Network.continueInterceptedRequest(continueParams);
					} catch (e) {
						console.log('Error here');
						console.log(e);
					}
				}
			} catch (e) {
				console.log('An error occured in interceptRequest');
				console.log(e);
			}
		})();
	}

	killProcess(pid) {
		return new Promise((resolve, reject) => {
			if (pid) {
				console.log('pid to kill', pid);
				console.log(this.currentProcess.kill());
				resolve(true);
				// process.kill(pid)
				// sp.exec(`kill ${pid}`,(err,stdout,stderr)=>{
				//   if(err){
				//     console.log('kill process error',err)
				//     reject(err)
				//   }
				//   resolve({stdout,stderr})
				// })
			}
		});
	}

	close() {
		var _this31 = this;

		return _asyncToGenerator(function* () {
			_this31.logDev('Closing Chrome');
			try {
				yield _this31.chrome.close();
			} catch (e) {
				console.log('Already closed');
				console.log(e);
			}
			try {
				yield _this31.killProcess(_this31.currentProcess.pid);
			} catch (e) {
				console.log(e);
			}
			return true;
		})();
	}

	uploadToS3(data) {
		return new Promise((resolve, reject) => {
			let name = 'screenshot_' + hat() + '_' + new Date().getTime() + '.png';
			const params = {
				Key: name,
				Body: data,
				Bucket: 'cynthiagrowthmachine',
				ACL: 'public-read-write',
				ContentType: "image/png",
				ContentEncoding: "base64"
			};
			s3.putObject(params, function (err, response) {
				if (err) {
					resolve(null);
				} else {
					response.fileName = name;
					resolve(response);
				}
			});
		});
	}
}

module.exports = Chrome;